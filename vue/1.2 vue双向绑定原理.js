/* 
    // Vue.js 数据双向绑定原理
    所谓双向数据绑定，无非就是数据层和视图层中的数据同步，在写入数据时，视图层实时的跟着更新。

    Vue.js 2.0 采用数据劫持(Proxy模式)结合发布者-订阅者模式(PubSub模式)的方法，通过Object.defineProperty()来劫持各个属性的setter、getter，
    在数据变动时发布消息给订阅者，触发相应的监听回调。

    // 每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

    Vue.js 3.0 放弃了Object.defineProperty()，使用ES6的Proxy（访问对象拦截器，也称代理器）

    // 步骤：
    //     1.实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可以拿到最新值并通知订阅者
    //     2.实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
    //     3.实现一个Watcher，作为Observer和Compild的桥梁，能够订阅并接收到每个属性的通知，执行指令绑定的相应回调函数，从而更新视图
    //     4.MVVM入口函数，整合以上三者

    具体步骤：
        1.需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，这样的话，
        给这个对象的某个值赋值，就会触发setter，那么就能监听到数据变化
        2.compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染河面视图，并将每个指令对应的节点绑定更新函数，
        添加监听数据的订阅者，一点数据有变动，收到通知，更新视图
        3.Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是：
            a) 在自身实例化时往属性订阅器(Dep)里添加自己
            b) 自身必须有一个Update()方法
            c) 待属性变动Dep.notice()通知时，能调用自身update()方法，并触发Compile中绑定的回调
        4.MVVM作为数据绑定的入口，整合Observer、Complie和Watcher三者，通过Observer来监听自己的model数据边防，通过Compile来解析变异模板指令，
        最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果
*/